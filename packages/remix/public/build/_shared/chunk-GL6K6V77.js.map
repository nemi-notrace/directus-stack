{
  "version": 3,
  "sources": ["../../../app/utils/theme-provider.tsx"],
  "sourcesContent": ["import React, {\n  createContext,\n  createElement,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from 'react'\nimport { useFetcher } from '@remix-run/react'\nimport type { Dispatch, ReactNode, SetStateAction } from 'react'\n\nenum Theme {\n  DARK = 'dark',\n  LIGHT = 'light',\n}\nconst themes: Array<Theme> = Object.values(Theme)\n\ntype ThemeContextType = [Theme | null, Dispatch<SetStateAction<Theme | null>>]\n\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined)\n\nconst prefersDarkMQ = '(prefers-color-scheme: dark)'\nconst getPreferredTheme = () =>\n  window.matchMedia(prefersDarkMQ).matches ? Theme.DARK : Theme.LIGHT\n\nfunction ThemeProvider({\n  children,\n  specifiedTheme,\n}: {\n  children: ReactNode\n  specifiedTheme: Theme | null\n}) {\n  const [theme, setTheme] = useState<Theme | null>(() => {\n    // On the server, if we don't have a specified theme then we should\n    // return null and the clientThemeCode will set the theme for us\n    // before hydration. Then (during hydration), this code will get the same\n    // value that clientThemeCode got so hydration is happy.\n    if (specifiedTheme) {\n      if (themes.includes(specifiedTheme)) {\n        return specifiedTheme\n      } else {\n        return null\n      }\n    }\n\n    // there's no way for us to know what the theme should be in this context\n    // the client will have to figure it out before hydration.\n    if (typeof document === 'undefined') {\n      return null\n    }\n\n    return getPreferredTheme()\n  })\n\n  const persistTheme = useFetcher()\n  // TODO: remove this when persistTheme is memoized properly\n  const persistThemeRef = useRef(persistTheme)\n  useEffect(() => {\n    persistThemeRef.current = persistTheme\n  }, [persistTheme])\n\n  const mountRun = useRef(false)\n\n  useEffect(() => {\n    if (!mountRun.current) {\n      mountRun.current = true\n      return\n    }\n    if (!theme) {\n      return\n    }\n\n    persistThemeRef.current.submit(\n      { theme },\n      { action: 'action/set-theme', method: 'post' },\n    )\n  }, [theme])\n\n  useEffect(() => {\n    const mediaQuery = window.matchMedia(prefersDarkMQ)\n    const handleChange = () => {\n      setTheme(mediaQuery.matches ? Theme.DARK : Theme.LIGHT)\n    }\n    mediaQuery.addEventListener('change', handleChange)\n    return () => mediaQuery.removeEventListener('change', handleChange)\n  }, [])\n\n  return (\n    <ThemeContext.Provider value={[theme, setTheme]}>\n      {children}\n    </ThemeContext.Provider>\n  )\n}\n\nconst clientThemeCode = `\n// hi there dear reader \uD83D\uDC4B\n// this is how I make certain we avoid a flash of the wrong theme. If you select\n// a theme, then I'll know what you want in the future and you'll not see this\n// script anymore.\n;(() => {\n  const theme = window.matchMedia(${JSON.stringify(prefersDarkMQ)}).matches\n    ? 'dark'\n    : 'light';\n  const cl = document.documentElement.classList;\n  const themeAlreadyApplied = cl.contains('light') || cl.contains('dark');\n  if (themeAlreadyApplied) {\n    // this script shouldn't exist if the theme is already applied!\n    console.warn(\n      \"Hi there, could you let me know you're seeing this message? Thanks!\",\n    );\n  } else {\n    cl.add(theme);\n  }\n  const meta = document.querySelector('meta[name=color-scheme]');\n  if (meta) {\n    if (theme === 'dark') {\n      meta.content = 'dark light';\n    } else if (theme === 'light') {\n      meta.content = 'light dark';\n    }\n  } else {\n    console.warn(\n      \"Hey, could you let me know you're seeing this message? Thanks!\",\n    );\n  }\n})();\n`\n\nconst themeStylesCode = `\n  /* default light, but app-preference is \"dark\" */\n  html.dark {\n    light-mode {\n      display: none;\n    }\n  }\n\n  /* default light, and no app-preference */\n  html:not(.dark) {\n    dark-mode {\n      display: none;\n    }\n  }\n\n  @media (prefers-color-scheme: dark) {\n    /* prefers dark, but app-preference is \"light\" */\n    html.light {\n      dark-mode {\n        display: none;\n      }\n    }\n\n    /* prefers dark, and app-preference is \"dark\" */\n    html.dark,\n    /* prefers dark and no app-preference */\n    html:not(.light) {\n      light-mode {\n        display: none;\n      }\n    }\n  }\n`\n\nfunction ThemeHead({ ssrTheme }: { ssrTheme: boolean }) {\n  const [theme] = useTheme()\n\n  return (\n    <>\n      {/*\n        On the server, \"theme\" might be `null`, so clientThemeCode ensures that\n        this is correct before hydration.\n      */}\n      <meta\n        name=\"color-scheme\"\n        content={theme === 'light' ? 'light dark' : 'dark light'}\n      />\n      {/*\n        If we know what the theme is from the server then we don't need\n        to do fancy tricks prior to hydration to make things match.\n      */}\n      {ssrTheme ? null : (\n        <>\n          <script\n            // NOTE: we cannot use type=\"module\" because that automatically makes\n            // the script \"defer\". That doesn't work for us because we need\n            // this script to run synchronously before the rest of the document\n            // is finished loading.\n            dangerouslySetInnerHTML={{ __html: clientThemeCode }}\n          />\n          <style dangerouslySetInnerHTML={{ __html: themeStylesCode }} />\n        </>\n      )}\n    </>\n  )\n}\n\nconst clientDarkAndLightModeElsCode = `;(() => {\n  const theme = window.matchMedia(${JSON.stringify(prefersDarkMQ)}).matches\n    ? 'dark'\n    : 'light';\n  const darkEls = document.querySelectorAll(\"dark-mode\");\n  const lightEls = document.querySelectorAll(\"light-mode\");\n  for (const darkEl of darkEls) {\n    if (theme === \"dark\") {\n      for (const child of darkEl.childNodes) {\n        darkEl.parentElement?.append(child);\n      }\n    }\n    darkEl.remove();\n  }\n  for (const lightEl of lightEls) {\n    if (theme === \"light\") {\n      for (const child of lightEl.childNodes) {\n        lightEl.parentElement?.append(child);\n      }\n    }\n    lightEl.remove();\n  }\n})();`\n\nfunction ThemeBody({ ssrTheme }: { ssrTheme: boolean }) {\n  return ssrTheme ? null : (\n    <script\n      dangerouslySetInnerHTML={{ __html: clientDarkAndLightModeElsCode }}\n    />\n  )\n}\n\nfunction useTheme() {\n  const context = useContext(ThemeContext)\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider')\n  }\n  return context\n}\n\n/**\n * This allows you to render something that depends on the theme without\n * worrying about whether it'll SSR properly when we don't actually know\n * the user's preferred theme.\n */\nfunction Themed({\n  dark,\n  light,\n  initialOnly = false,\n}: {\n  dark: ReactNode | string\n  light: ReactNode | string\n  initialOnly?: boolean\n}) {\n  const [theme] = useTheme()\n  const [initialTheme] = useState(theme)\n  const themeToReference = initialOnly ? initialTheme : theme\n  const serverRenderWithUnknownTheme = !theme && typeof document === 'undefined'\n\n  if (serverRenderWithUnknownTheme) {\n    // stick them both in and our little script will update the DOM to match\n    // what we'll render in the client during hydration.\n    return (\n      <>\n        {createElement('dark-mode', null, dark)}\n        {createElement('light-mode', null, light)}\n      </>\n    )\n  }\n\n  return <>{themeToReference === 'light' ? light : dark}</>\n}\n\nfunction isTheme(value: unknown): value is Theme {\n  return typeof value === 'string' && themes.includes(value as Theme)\n}\n\nexport { isTheme, Theme, Themed, ThemeBody, ThemeHead, ThemeProvider, useTheme }\n"],
  "mappings": "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",
  "names": ["Theme"]
}
